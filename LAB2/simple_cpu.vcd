$date
	Thu May 14 20:12:21 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TestBench $end
$scope module cpu $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$var wire 1 # zero_alu $end
$var wire 32 $ pc_plus_4 [31:0] $end
$var wire 32 % pc_out [31:0] $end
$var wire 32 & pc_in [31:0] $end
$var wire 5 ' number_WriteReg_fromMux [4:0] $end
$var wire 32 ( instruction [31:0] $end
$var wire 32 ) data_into_ALU_after_mux [31:0] $end
$var wire 32 * data_after_se [31:0] $end
$var wire 32 + data_after_left2 [31:0] $end
$var wire 32 , branch_target_addr [31:0] $end
$var wire 1 - branch $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 32 0 RT_data [31:0] $end
$var wire 32 1 RS_data [31:0] $end
$var wire 32 2 RD_data [31:0] $end
$var wire 4 3 AlU_control [3:0] $end
$var wire 1 4 ALUSrc $end
$var wire 3 5 ALUOp [2:0] $end
$scope module AC $end
$var wire 6 6 funct_i [5:0] $end
$var wire 3 7 ALUOp_i [2:0] $end
$var reg 4 8 ALUCtrl_o [3:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 9 ctrl_i [3:0] $end
$var wire 5 : shamt_i [4:0] $end
$var wire 5 ; tmp_shamt [4:0] $end
$var wire 32 < tmp_src1 [31:0] $end
$var wire 32 = tmp_src2 [31:0] $end
$var wire 32 > src2_i [31:0] $end
$var wire 32 ? src1_i [31:0] $end
$var reg 32 @ result_o [31:0] $end
$var reg 1 # zero_o $end
$upscope $end
$scope module Adder1 $end
$var wire 32 A src2_i [31:0] $end
$var wire 32 B sum_o [31:0] $end
$var wire 32 C src1_i [31:0] $end
$upscope $end
$scope module Adder2 $end
$var wire 32 D src1_i [31:0] $end
$var wire 32 E sum_o [31:0] $end
$var wire 32 F src2_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 6 G instr_op_i [5:0] $end
$var reg 1 4 ALUSrc_o $end
$var reg 3 H ALU_op_o [2:0] $end
$var reg 1 - Branch_o $end
$var reg 1 / RegDst_o $end
$var reg 1 . RegWrite_o $end
$upscope $end
$scope module IM $end
$var wire 32 I pc_addr_i [31:0] $end
$var reg 32 J instr_o [31:0] $end
$var integer 32 K i [31:0] $end
$upscope $end
$scope module Mux_ALUSrc $end
$var wire 1 4 select_i $end
$var wire 32 L data1_i [31:0] $end
$var wire 32 M data0_i [31:0] $end
$var reg 32 N data_o [31:0] $end
$upscope $end
$scope module Mux_PC_Source $end
$var wire 32 O data0_i [31:0] $end
$var wire 32 P data1_i [31:0] $end
$var wire 1 Q select_i $end
$var reg 32 R data_o [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 S data0_i [4:0] $end
$var wire 5 T data1_i [4:0] $end
$var wire 1 / select_i $end
$var reg 5 U data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 V pc_in_i [31:0] $end
$var wire 1 " rst_i $end
$var reg 32 W pc_out_o [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 X RDaddr_i [4:0] $end
$var wire 32 Y RDdata_i [31:0] $end
$var wire 5 Z RSaddr_i [4:0] $end
$var wire 32 [ RSdata_o [31:0] $end
$var wire 5 \ RTaddr_i [4:0] $end
$var wire 32 ] RTdata_o [31:0] $end
$var wire 1 . RegWrite_i $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$upscope $end
$scope module SE $end
$var wire 4 ^ ctrl_i [3:0] $end
$var wire 16 _ data_i [15:0] $end
$var reg 32 ` data_o [31:0] $end
$upscope $end
$scope module Shifter $end
$var wire 32 a data_i [31:0] $end
$var wire 32 b data_o [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx00 b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
xQ
bx P
bx O
bx N
bx M
bx L
b100000 K
bx J
bx I
bx H
bx G
bx00 F
bx E
bx D
bx C
bx B
b100 A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
bx 3
bx 2
bx 1
bx 0
x/
x.
x-
bx ,
bx00 +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
x#
0"
0!
$end
#5
1Q
1#
b1 2
b1 @
b1 Y
b1000 &
b1000 R
b1000 V
b0 =
b0 )
b0 >
b0 N
b1001 3
b1001 8
b1001 9
b1001 ^
b1000 ,
b1000 E
b1000 P
b100 +
b100 F
b100 b
b1 *
b1 L
b1 `
b1 a
1-
0/
04
b110 5
b110 7
b110 H
0.
b0 '
b0 U
b0 X
b0 ;
b0 :
b1 _
b1 6
b101 G
b0 0
b0 M
b0 ]
b0 \
b1 <
b1 1
b1 ?
b1 [
b1 Z
b0 T
b0 S
b10100001000000000000000000001 (
b10100001000000000000000000001 J
b100 $
b100 B
b100 D
b100 O
b0 %
b0 C
b0 I
b0 W
1!
#10
0!
1"
#15
0#
b1111 3
b1111 8
b1111 9
b1111 ^
b1110000000011100 +
b1110000000011100 F
b1110000000011100 b
0Q
b11100000000111 *
b11100000000111 L
b11100000000111 `
b11100000000111 a
0-
1/
b0 5
b0 7
b0 H
1.
b111 =
b111 )
b111 >
b111 N
b1 2
b1 @
b1 Y
b111 '
b111 U
b111 X
b1100 &
b1100 R
b1100 V
b11100000000111 _
b111 6
b0 G
b111 0
b111 M
b111 ]
b111 \
b10 <
b10 1
b10 ?
b10 [
b10 Z
b111 T
b111 S
b10001110011100000000111 (
b10001110011100000000111 J
b1110000000101000 ,
b1110000000101000 E
b1110000000101000 P
b1100 $
b1100 B
b1100 D
b1100 O
b1000 %
b1000 C
b1000 I
b1000 W
1!
#20
0!
#25
1#
b0 +
b0 F
b0 b
b0 *
b0 L
b0 `
b0 a
b0 2
b0 @
b0 Y
b0 '
b0 U
b0 X
b10000 &
b10000 R
b10000 V
b0 =
b0 )
b0 >
b0 N
b0 _
b0 6
b0 \
b0 <
b0 1
b0 ?
b0 [
b0 Z
b0 T
b0 S
b0 (
b0 J
b10000 ,
b10000 E
b10000 P
b10000 $
b10000 B
b10000 D
b10000 O
b1100 %
b1100 C
b1100 I
b1100 W
b0 0
b0 M
b0 ]
1!
#30
0!
#35
b10100 &
b10100 R
b10100 V
b10100 ,
b10100 E
b10100 P
b10100 $
b10100 B
b10100 D
b10100 O
b10000 %
b10000 C
b10000 I
b10000 W
1!
#40
0!
#45
b11000 &
b11000 R
b11000 V
b11000 ,
b11000 E
b11000 P
b11000 $
b11000 B
b11000 D
b11000 O
b10100 %
b10100 C
b10100 I
b10100 W
1!
